<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>me</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-5.9.3' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/1.html#L15'>me</a>                 15 branch.c           struct node *me;</span>
<span class='curline'><a href='../S/1.html#L21'>me</a>                 21 branch.c           me = tree;</span>
<span class='curline'><a href='../S/1.html#L28'>me</a>                 28 branch.c           tsplit = me-&gt;primary;</span>
<span class='curline'><a href='../S/1.html#L49'>me</a>                 49 branch.c           for (tsplit= me-&gt;surrogate; tsplit !=0; tsplit= tsplit-&gt;nextsplit) {</span>
<span class='curline'><a href='../S/1.html#L72'>me</a>                 72 branch.c           dir = me-&gt;lastsurrogate;</span>
<span class='curline'><a href='../S/1.html#L74'>me</a>                 74 branch.c       down:if (dir==LEFT) return(me-&gt;leftson);</span>
<span class='curline'><a href='../S/1.html#L75'>me</a>                 75 branch.c            else           return(me-&gt;rightson);</span>
<span class='curline'><a href='../S/18.html#L17'>me</a>                 17 bsplit.c       void bsplit(struct node *me, int nodenum)</span>
<span class='curline'><a href='../S/18.html#L38'>me</a>                 38 bsplit.c           me-&gt;primary =0;</span>
<span class='curline'><a href='../S/18.html#L74'>me</a>                 74 bsplit.c                        &amp;split, rp.csplit, me-&gt;risk, wtemp);</span>
<span class='curline'><a href='../S/18.html#L84'>me</a>                 84 bsplit.c               tsplit = insert_split(&amp;(me-&gt;primary), nc, improve, rp.maxpri);</span>
<span class='curline'><a href='../S/33.html#L11'>me</a>                 11 fix_cp.c       void fix_cp(struct node *me, double parent_cp)</span>
<span class='curline'><a href='../S/33.html#L13'>me</a>                 13 fix_cp.c           if (me-&gt;complexity &gt; parent_cp)  me-&gt;complexity = parent_cp;</span>
<span class='curline'><a href='../S/33.html#L15'>me</a>                 15 fix_cp.c           if (me-&gt;leftson != 0) {</span>
<span class='curline'><a href='../S/33.html#L16'>me</a>                 16 fix_cp.c           fix_cp(me-&gt;leftson, me-&gt;complexity);</span>
<span class='curline'><a href='../S/33.html#L17'>me</a>                 17 fix_cp.c           fix_cp(me-&gt;rightson,me-&gt;complexity);</span>
<span class='curline'><a href='../S/10.html#L35'>me</a>                 35 make_cp_list.c void make_cp_list(struct node *me, double parent, struct cptable *cptable_head)</span>
<span class='curline'><a href='../S/10.html#L40'>me</a>                 40 make_cp_list.c     if (me-&gt;complexity &gt; parent) me-&gt;complexity = parent;</span>
<span class='curline'><a href='../S/10.html#L41'>me</a>                 41 make_cp_list.c     me_cp = me-&gt;complexity;</span>
<span class='curline'><a href='../S/10.html#L43'>me</a>                 43 make_cp_list.c     if (me-&gt;leftson != 0) {</span>
<span class='curline'><a href='../S/10.html#L44'>me</a>                 44 make_cp_list.c      make_cp_list(me-&gt;leftson, me_cp, cptable_head);</span>
<span class='curline'><a href='../S/10.html#L45'>me</a>                 45 make_cp_list.c      make_cp_list(me-&gt;rightson,me_cp, cptable_head);</span>
<span class='curline'><a href='../S/25.html#L19'>me</a>                 19 make_cp_table.c struct cptable *make_cp_table(struct node *me, double parent, int nsplit)</span>
<span class='curline'><a href='../S/25.html#L23'>me</a>                 23 make_cp_table.c     if (me-&gt;leftson) {  /* if there are splits below */</span>
<span class='curline'><a href='../S/25.html#L31'>me</a>                 31 make_cp_table.c     make_cp_table(me-&gt;leftson, me-&gt;complexity, 0);</span>
<span class='curline'><a href='../S/25.html#L32'>me</a>                 32 make_cp_table.c     cplist = make_cp_table(me-&gt;rightson, me-&gt;complexity, nsplit+1);</span>
<span class='curline'><a href='../S/25.html#L37'>me</a>                 37 make_cp_table.c     cplist-&gt;risk += me-&gt;risk;</span>
<span class='curline'><a href='../S/17.html#L10'>me</a>                 10 nodesplit.c    void nodesplit(struct node *me, int nodenum)</span>
<span class='curline'><a href='../S/17.html#L31'>me</a>                 31 nodesplit.c        tsplit = me-&gt;primary;</span>
<span class='curline'><a href='../S/17.html#L64'>me</a>                 64 nodesplit.c        for (tsplit=me-&gt;surrogate;  tsplit!=0 &amp;&amp; someleft&gt;0;</span>
<span class='curline'><a href='../S/17.html#L115'>me</a>                115 nodesplit.c        i = me-&gt;lastsurrogate;</span>
<span class='curline'><a href='../S/23.html#L19'>me</a>                 19 partition.c        struct node *me;</span>
<span class='curline'><a href='../S/23.html#L29'>me</a>                 29 partition.c        me = splitnode;</span>
<span class='curline'><a href='../S/23.html#L62'>me</a>                 62 partition.c        (*rp_eval)(j, rp.ytemp, me-&gt;response_est, &amp;(me-&gt;risk), rp.wtemp);</span>
<span class='curline'><a href='../S/23.html#L63'>me</a>                 63 partition.c        me -&gt; num_obs = j;</span>
<span class='curline'><a href='../S/23.html#L64'>me</a>                 64 partition.c        me -&gt; sum_wt  = twt;</span>
<span class='curline'><a href='../S/23.html#L65'>me</a>                 65 partition.c        tempcp = me-&gt;risk;</span>
<span class='curline'><a href='../S/23.html#L66'>me</a>                 66 partition.c        if (tempcp &gt; me-&gt;complexity)  tempcp = me-&gt;complexity;</span>
<span class='curline'><a href='../S/23.html#L69'>me</a>                 69 partition.c        tempcp = me-&gt;risk;</span>
<span class='curline'><a href='../S/23.html#L75'>me</a>                 75 partition.c        if (me-&gt;num_obs &lt; rp.min_split  ||  tempcp &lt;= rp.alpha  || </span>
<span class='curline'><a href='../S/23.html#L77'>me</a>                 77 partition.c        me-&gt;complexity =  rp.alpha;</span>
<span class='curline'><a href='../S/23.html#L78'>me</a>                 78 partition.c        me-&gt;leftson = (struct node *)0;</span>
<span class='curline'><a href='../S/23.html#L79'>me</a>                 79 partition.c        me-&gt;rightson= (struct node *)0;</span>
<span class='curline'><a href='../S/23.html#L80'>me</a>                 80 partition.c        *sumrisk = me-&gt;risk;</span>
<span class='curline'><a href='../S/23.html#L87'>me</a>                 87 partition.c        bsplit(me, nodenum);</span>
<span class='curline'><a href='../S/23.html#L88'>me</a>                 88 partition.c        if (me-&gt;primary ==0) {</span>
<span class='curline'><a href='../S/23.html#L92'>me</a>                 92 partition.c        me-&gt;complexity = rp.alpha;</span>
<span class='curline'><a href='../S/23.html#L93'>me</a>                 93 partition.c        me-&gt;leftson = (struct node *)0;</span>
<span class='curline'><a href='../S/23.html#L94'>me</a>                 94 partition.c        me-&gt;rightson= (struct node *)0;</span>
<span class='curline'><a href='../S/23.html#L95'>me</a>                 95 partition.c        *sumrisk = me-&gt;risk;</span>
<span class='curline'><a href='../S/23.html#L99'>me</a>                 99 partition.c        if (rp.maxsur&gt;0) (void)surrogate(me, nodenum);</span>
<span class='curline'><a href='../S/23.html#L100'>me</a>                100 partition.c        else  me-&gt;surrogate =0;</span>
<span class='curline'><a href='../S/23.html#L101'>me</a>                101 partition.c        nodesplit(me, nodenum);</span>
<span class='curline'><a href='../S/23.html#L106'>me</a>                106 partition.c        me-&gt;leftson = (struct node *)CALLOC(1, nodesize);</span>
<span class='curline'><a href='../S/23.html#L107'>me</a>                107 partition.c        (me-&gt;leftson)-&gt;complexity = tempcp - rp.alpha;</span>
<span class='curline'><a href='../S/23.html#L108'>me</a>                108 partition.c        left_split = partition(2*nodenum, me-&gt;leftson, &amp;left_risk);</span>
<span class='curline'><a href='../S/23.html#L113'>me</a>                113 partition.c        tempcp = (me-&gt;risk - left_risk) / (left_split +1);</span>
<span class='curline'><a href='../S/23.html#L114'>me</a>                114 partition.c        tempcp2 =(me-&gt;risk - (me-&gt;leftson)-&gt;risk);</span>
<span class='curline'><a href='../S/23.html#L116'>me</a>                116 partition.c        if (tempcp &gt; me-&gt;complexity)  tempcp = me-&gt;complexity;</span>
<span class='curline'><a href='../S/23.html#L118'>me</a>                118 partition.c        me-&gt;rightson = (struct node *) CALLOC(1, nodesize);</span>
<span class='curline'><a href='../S/23.html#L119'>me</a>                119 partition.c        (me-&gt;rightson)-&gt;complexity = tempcp - rp.alpha;</span>
<span class='curline'><a href='../S/23.html#L120'>me</a>                120 partition.c        right_split = partition(1+2*nodenum, me-&gt;rightson, &amp;right_risk);</span>
<span class='curline'><a href='../S/23.html#L128'>me</a>                128 partition.c        tempcp = (me-&gt;risk - (left_risk + right_risk))/</span>
<span class='curline'><a href='../S/23.html#L132'>me</a>                132 partition.c        if ( (me-&gt;rightson)-&gt;complexity  &gt; (me-&gt;leftson)-&gt;complexity ) {</span>
<span class='curline'><a href='../S/23.html#L133'>me</a>                133 partition.c        if (tempcp &gt; (me-&gt;leftson)-&gt;complexity) {</span>
<span class='curline'><a href='../S/23.html#L135'>me</a>                135 partition.c            left_risk = (me-&gt;leftson)-&gt;risk;</span>
<span class='curline'><a href='../S/23.html#L138'>me</a>                138 partition.c            tempcp = (me-&gt;risk - (left_risk + right_risk)) /</span>
<span class='curline'><a href='../S/23.html#L140'>me</a>                140 partition.c            if (tempcp &gt; (me-&gt;rightson)-&gt;complexity) {</span>
<span class='curline'><a href='../S/23.html#L142'>me</a>                142 partition.c            right_risk = (me-&gt;rightson)-&gt;risk;</span>
<span class='curline'><a href='../S/23.html#L148'>me</a>                148 partition.c        else if (tempcp &gt; (me-&gt;rightson)-&gt;complexity) {</span>
<span class='curline'><a href='../S/23.html#L151'>me</a>                151 partition.c        right_risk = (me-&gt;rightson)-&gt;risk;</span>
<span class='curline'><a href='../S/23.html#L153'>me</a>                153 partition.c        tempcp = (me-&gt;risk - (left_risk + right_risk)) /</span>
<span class='curline'><a href='../S/23.html#L155'>me</a>                155 partition.c        if (tempcp &gt; (me-&gt;leftson)-&gt;complexity) {</span>
<span class='curline'><a href='../S/23.html#L157'>me</a>                157 partition.c            left_risk = (me-&gt;leftson)-&gt;risk;</span>
<span class='curline'><a href='../S/23.html#L162'>me</a>                162 partition.c        me-&gt;complexity= (me-&gt;risk - (left_risk + right_risk))/</span>
<span class='curline'><a href='../S/23.html#L165'>me</a>                165 partition.c        if (me-&gt;complexity &lt;= rp.alpha ) {</span>
<span class='curline'><a href='../S/23.html#L169'>me</a>                169 partition.c        free_tree(me-&gt;leftson, 1);</span>
<span class='curline'><a href='../S/23.html#L170'>me</a>                170 partition.c        free_tree(me-&gt;rightson,1);</span>
<span class='curline'><a href='../S/23.html#L171'>me</a>                171 partition.c        me-&gt;leftson = (struct node *)0;</span>
<span class='curline'><a href='../S/23.html#L172'>me</a>                172 partition.c        me-&gt;rightson= (struct node *)0;</span>
<span class='curline'><a href='../S/23.html#L173'>me</a>                173 partition.c        *sumrisk = me-&gt;risk;</span>
<span class='curline'><a href='../S/30.html#L10'>me</a>                 10 rpartproto.h   void bsplit(struct node *me, int nodenum);</span>
<span class='curline'><a href='../S/30.html#L16'>me</a>                 16 rpartproto.h   void fix_cp(struct node *me, double parent_cp);</span>
<span class='curline'><a href='../S/30.html#L28'>me</a>                 28 rpartproto.h   void make_cp_list(struct node *me, double parent, </span>
<span class='curline'><a href='../S/30.html#L31'>me</a>                 31 rpartproto.h   struct cptable *make_cp_table(struct node *me, double parent, int nsplit);</span>
<span class='curline'><a href='../S/30.html#L35'>me</a>                 35 rpartproto.h   void nodesplit(struct node *me, int nodenum);</span>
<span class='curline'><a href='../S/30.html#L57'>me</a>                 57 rpartproto.h   void rpcountup(struct node *me, Sint *nnode, Sint *nsplit, int *ncat);</span>
<span class='curline'><a href='../S/30.html#L62'>me</a>                 62 rpartproto.h   void rpmatrix(struct node *me,  Sint *nodecount,   Sint *splitcount, </span>
<span class='curline'><a href='../S/30.html#L88'>me</a>                 88 rpartproto.h   void surrogate(struct node *me, int nodenum);</span>
<span class='curline'><a href='../S/2.html#L12'>me</a>                 12 rpcountup.c    void rpcountup(struct node *me, Sint *nnode, Sint *nsplit, int *ncat)</span>
<span class='curline'><a href='../S/2.html#L19'>me</a>                 19 rpcountup.c        if (me-&gt;complexity &lt;=rp.alpha || me-&gt;leftson==0) { /*no kids */</span>
<span class='curline'><a href='../S/2.html#L26'>me</a>                 26 rpcountup.c        for (ss= me-&gt;primary;   ss!=0; ss = ss-&gt;nextsplit) {</span>
<span class='curline'><a href='../S/2.html#L30'>me</a>                 30 rpcountup.c        for (ss= me-&gt;surrogate; ss!=0; ss = ss-&gt;nextsplit) {</span>
<span class='curline'><a href='../S/2.html#L35'>me</a>                 35 rpcountup.c        rpcountup(me-&gt;leftson, nnode,  nsplit,  ncat);</span>
<span class='curline'><a href='../S/2.html#L36'>me</a>                 36 rpcountup.c        rpcountup(me-&gt;rightson,&amp;node2, &amp;split2, &amp;cat2);</span>
<span class='curline'><a href='../S/4.html#L9'>me</a>                  9 rpmatrix.c     void rpmatrix(struct node *me,  Sint *nodecount,   Sint *splitcount, </span>
<span class='curline'><a href='../S/4.html#L41'>me</a>                 41 rpmatrix.c         cp_scale = 1/ me-&gt;risk;</span>
<span class='curline'><a href='../S/4.html#L46'>me</a>                 46 rpmatrix.c         dnode[0][ncnt] = me-&gt;risk;</span>
<span class='curline'><a href='../S/4.html#L47'>me</a>                 47 rpmatrix.c         dnode[1][ncnt] = me-&gt;complexity * cp_scale;</span>
<span class='curline'><a href='../S/4.html#L48'>me</a>                 48 rpmatrix.c         dnode[2][ncnt] = me-&gt;sum_wt;</span>
<span class='curline'><a href='../S/4.html#L50'>me</a>                 50 rpmatrix.c         for (i=0; i&lt;(rp.num_resp); i++) dnode[3+i][ncnt] = me-&gt;response_est[i];</span>
<span class='curline'><a href='../S/4.html#L53'>me</a>                 53 rpmatrix.c         inode[4][ncnt] = me-&gt;num_obs;</span>
<span class='curline'><a href='../S/4.html#L55'>me</a>                 55 rpmatrix.c         if (me-&gt;complexity &lt;=rp.alpha || me-&gt;leftson==0) { /*no kids */</span>
<span class='curline'><a href='../S/4.html#L59'>me</a>                 59 rpmatrix.c         inode[5][ncnt] = me-&gt;num_obs;</span>
<span class='curline'><a href='../S/4.html#L66'>me</a>                 66 rpmatrix.c         for (spl = me-&gt;primary; spl!=0; spl = spl-&gt;nextsplit) {</span>
<span class='curline'><a href='../S/4.html#L87'>me</a>                 87 rpmatrix.c         for (spl=me-&gt;surrogate; spl!=0; spl = spl-&gt;nextsplit) {</span>
<span class='curline'><a href='../S/4.html#L107'>me</a>                107 rpmatrix.c         inode[5][ncnt] = me-&gt;num_obs -</span>
<span class='curline'><a href='../S/4.html#L108'>me</a>                108 rpmatrix.c                    ((me-&gt;leftson)-&gt;num_obs + (me-&gt;rightson)-&gt;num_obs);</span>
<span class='curline'><a href='../S/4.html#L115'>me</a>                115 rpmatrix.c         rpmatrix(me-&gt;leftson, nodecount, splitcount, catcount, numcat,</span>
<span class='curline'><a href='../S/4.html#L117'>me</a>                117 rpmatrix.c         rpmatrix(me-&gt;rightson,nodecount, splitcount, catcount, numcat,</span>
<span class='curline'><a href='../S/37.html#L20'>me</a>                 20 surrogate.c    void surrogate(struct node *me, int nodenum)</span>
<span class='curline'><a href='../S/37.html#L47'>me</a>                 47 surrogate.c        var = (me-&gt;primary)-&gt;var_num;</span>
<span class='curline'><a href='../S/37.html#L49'>me</a>                 49 surrogate.c        split = (me-&gt;primary)-&gt;spoint;</span>
<span class='curline'><a href='../S/37.html#L50'>me</a>                 50 surrogate.c        extra = (me-&gt;primary)-&gt;csplit[0];</span>
<span class='curline'><a href='../S/37.html#L64'>me</a>                 64 surrogate.c        index = (me-&gt;primary)-&gt;csplit;</span>
<span class='curline'><a href='../S/37.html#L82'>me</a>                 82 surrogate.c        if (lcount &lt; rcount) me-&gt;lastsurrogate = RIGHT;</span>
<span class='curline'><a href='../S/37.html#L83'>me</a>                 83 surrogate.c        else                 me-&gt;lastsurrogate = LEFT;</span>
<span class='curline'><a href='../S/37.html#L88'>me</a>                 88 surrogate.c        me-&gt;surrogate =0;</span>
<span class='curline'><a href='../S/37.html#L99'>me</a>                 99 surrogate.c        ss = insert_split( &amp;(me-&gt;surrogate), ncat, improve, rp.maxsur);</span>
</pre>
</body>
</html>
