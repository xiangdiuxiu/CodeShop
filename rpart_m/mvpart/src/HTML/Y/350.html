<!DOCTYPE html PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml'>
<head>
<title>x</title>
<meta name='robots' content='noindex,nofollow' />
<meta name='generator' content='GLOBAL-5.9.3' />
<meta http-equiv='Content-Style-Type' content='text/css' />
<link rel='stylesheet' type='text/css' href='../style.css' />
</head>
<body>
<pre>
<span class='curline'><a href='../S/12.html#L64'>x</a>                  64 anova.c        void anova(int n,    double *y[],     FLOAT *x,     int nclass, </span>
<span class='curline'><a href='../S/12.html#L109'>x</a>                 109 anova.c                if (x[i+1] !=x[i] &amp;&amp;  left_n&gt;=edge) {</span>
<span class='curline'><a href='../S/12.html#L125'>x</a>                 125 anova.c                *split = (x[where] + x[where+1]) /2;</span>
<span class='curline'><a href='../S/12.html#L141'>x</a>                 141 anova.c                j = (int)x[i] -1;</span>
<span class='curline'><a href='../S/24.html#L15'>x</a>                  15 choose_surg.c  void choose_surg(int nodenum,    int *y,         FLOAT *x,     Sint *order, </span>
<span class='curline'><a href='../S/24.html#L54'>x</a>                  54 choose_surg.c          lastx = x[i];        /*this is why I ran the loop backwards*/</span>
<span class='curline'><a href='../S/24.html#L81'>x</a>                  81 choose_surg.c          if ((lr+rr)&gt;=2  &amp;&amp;  x[i] != lastx) {</span>
<span class='curline'><a href='../S/24.html#L86'>x</a>                  86 choose_surg.c              *split = (x[i] + lastx)/2;</span>
<span class='curline'><a href='../S/24.html#L91'>x</a>                  91 choose_surg.c              *split = (x[i] + lastx)/2;</span>
<span class='curline'><a href='../S/24.html#L106'>x</a>                 106 choose_surg.c          lastx = x[i];</span>
<span class='curline'><a href='../S/24.html#L126'>x</a>                 126 choose_surg.c          j = (int)x[i] -1;</span>
<span class='curline'><a href='../S/11.html#L59'>x</a>                  59 dist.c         void dist(int n,    double *y[],  FLOAT *x,     int nclass, </span>
<span class='curline'><a href='../S/11.html#L104'>x</a>                 104 dist.c                 if (x[i+1] !=x[i] &amp;&amp;  left_n&gt;=edge) {</span>
<span class='curline'><a href='../S/11.html#L119'>x</a>                 119 dist.c                 *split = (x[where] + x[where+1]) /2;</span>
<span class='curline'><a href='../S/11.html#L138'>x</a>                 138 dist.c             k = x[0]-1;</span>
<span class='curline'><a href='../S/11.html#L142'>x</a>                 142 dist.c             k = x[i]-1;</span>
<span class='curline'><a href='../S/11.html#L145'>x</a>                 145 dist.c                 kj = x[j]-1;    </span>
<span class='curline'><a href='../S/16.html#L10'>x</a>                  10 formatg.c      void formatg( Sint *n, double *x, char **format, char **out) </span>
<span class='curline'><a href='../S/16.html#L19'>x</a>                  19 formatg.c          sprintf(out[i], format[i], x[i]);</span>
<span class='curline'><a href='../S/7.html#L43'>x</a>                  43 func_table.h   extern void anova(    int n,    double *y[],     FLOAT *x,     int nclass, </span>
<span class='curline'><a href='../S/7.html#L46'>x</a>                  46 func_table.h   extern void mrt(    int n,    double *y[],     FLOAT *x,     int nclass, </span>
<span class='curline'><a href='../S/7.html#L49'>x</a>                  49 func_table.h   extern void dist(    int n,    double *y[],     FLOAT *x,     int nclass, </span>
<span class='curline'><a href='../S/7.html#L52'>x</a>                  52 func_table.h   extern void poisson(  int n,    double *y[],     FLOAT *x,     int nclass, </span>
<span class='curline'><a href='../S/7.html#L55'>x</a>                  55 func_table.h   extern void gini(     int n,    double *y[],     FLOAT *x,     int nclass, </span>
<span class='curline'><a href='../S/7.html#L58'>x</a>                  58 func_table.h   extern void usersplit(int n,    double *y[],     FLOAT *x,     int nclass, </span>
<span class='curline'><a href='../S/19.html#L161'>x</a>                 161 gini.c         void gini(int n,    double *y[],     FLOAT *x,     int numcat,</span>
<span class='curline'><a href='../S/19.html#L207'>x</a>                 207 gini.c             if (x[i+1] != x[i] &amp;&amp;  (ltot&gt;=edge)) {</span>
<span class='curline'><a href='../S/19.html#L230'>x</a>                 230 gini.c             *split = (x[where] + x[where+1]) /2;</span>
<span class='curline'><a href='../S/19.html#L247'>x</a>                 247 gini.c             k = x[i] -1;</span>
<span class='curline'><a href='../S/8.html#L98'>x</a>                  98 mrt.c          void mrt(int n,    double *y[],  FLOAT *x,     int nclass,</span>
<span class='curline'><a href='../S/8.html#L147'>x</a>                 147 mrt.c                 if (x[i+1] != x[i] &amp;&amp;  left_n&gt;=edge) {</span>
<span class='curline'><a href='../S/8.html#L165'>x</a>                 165 mrt.c                  *split = (x[where] + x[where+1]) /2;</span>
<span class='curline'><a href='../S/8.html#L176'>x</a>                 176 mrt.c                      k = x[i] -1;</span>
<span class='curline'><a href='../S/26.html#L13'>x</a>                  13 mysort.c       void mysort(int start, int stop, FLOAT *x, int *cvec)</span>
<span class='curline'><a href='../S/26.html#L25'>x</a>                  25 mysort.c               temp = x[i];</span>
<span class='curline'><a href='../S/26.html#L29'>x</a>                  29 mysort.c               while (j&gt;=start &amp;&amp; (x[j]&gt;temp)) {</span>
<span class='curline'><a href='../S/26.html#L30'>x</a>                  30 mysort.c               x[j+1] = x[j];</span>
<span class='curline'><a href='../S/26.html#L34'>x</a>                  34 mysort.c               x[j+1] = temp;</span>
<span class='curline'><a href='../S/26.html#L48'>x</a>                  48 mysort.c           median = x[k];</span>
<span class='curline'><a href='../S/26.html#L49'>x</a>                  49 mysort.c           if (x[i] &gt;= x[k]) {      /* one of j or k is smallest */</span>
<span class='curline'><a href='../S/26.html#L50'>x</a>                  50 mysort.c           if (x[j] &gt; x[k]) {   /* k is smallest */</span>
<span class='curline'><a href='../S/26.html#L51'>x</a>                  51 mysort.c               if (x[i] &gt; x[j])  median = x[j];</span>
<span class='curline'><a href='../S/26.html#L52'>x</a>                  52 mysort.c               else median= x[i];</span>
<span class='curline'><a href='../S/26.html#L56'>x</a>                  56 mysort.c           if (x[j] &lt; x[k]) {</span>
<span class='curline'><a href='../S/26.html#L57'>x</a>                  57 mysort.c               if (x[i] &gt; x[j]) median = x[i];</span>
<span class='curline'><a href='../S/26.html#L58'>x</a>                  58 mysort.c               else median = x[j];</span>
<span class='curline'><a href='../S/26.html#L79'>x</a>                  79 mysort.c           while (x[i] &lt; median) i++;</span>
<span class='curline'><a href='../S/26.html#L84'>x</a>                  84 mysort.c           while(x[j] &gt; median) j--;</span>
<span class='curline'><a href='../S/26.html#L87'>x</a>                  87 mysort.c               if (x[i] &gt; x[j]) {  /* swap */</span>
<span class='curline'><a href='../S/26.html#L88'>x</a>                  88 mysort.c               temp = x[i];</span>
<span class='curline'><a href='../S/26.html#L89'>x</a>                  89 mysort.c               x[i] = x[j];</span>
<span class='curline'><a href='../S/26.html#L90'>x</a>                  90 mysort.c               x[j] = temp;</span>
<span class='curline'><a href='../S/26.html#L103'>x</a>                 103 mysort.c           while (x[i] &gt;= median &amp;&amp; i&gt;start) i--;</span>
<span class='curline'><a href='../S/26.html#L104'>x</a>                 104 mysort.c           while (x[j] &lt;= median &amp;&amp; j&lt;stop ) j++;</span>
<span class='curline'><a href='../S/26.html#L112'>x</a>                 112 mysort.c           if ((i-start)&gt;0) mysort(start,i, x, cvec);</span>
<span class='curline'><a href='../S/26.html#L117'>x</a>                 117 mysort.c           if ((stop -j)&gt;0) mysort(j,stop, x, cvec);</span>
<span class='curline'><a href='../S/13.html#L159'>x</a>                 159 poisson.c      void poisson(int n,       double **y,      FLOAT *x,     int nclass, </span>
<span class='curline'><a href='../S/13.html#L210'>x</a>                 210 poisson.c          if (x[i+1] !=x[i] &amp;&amp;  (1+i)&gt;=edge) {</span>
<span class='curline'><a href='../S/13.html#L228'>x</a>                 228 poisson.c          *split = (x[where] + x[where+1]) /2;</span>
<span class='curline'><a href='../S/13.html#L240'>x</a>                 240 poisson.c          j = x[i] -1;</span>
<span class='curline'><a href='../S/22.html#L107'>x</a>                 107 rpart_callback.c              FLOAT *x, double *good) {</span>
<span class='curline'><a href='../S/22.html#L122'>x</a>                 122 rpart_callback.c     xdata[i] = x[i];</span>
<span class='curline'><a href='../S/30.html#L12'>x</a>                  12 rpartproto.h   void choose_surg(int nodenum,    int *y,            FLOAT *x,     Sint *order, </span>
<span class='curline'><a href='../S/30.html#L33'>x</a>                  33 rpartproto.h   void mysort(int start, int stop, FLOAT *x, int *cvec);</span>
<span class='curline'><a href='../S/30.html#L55'>x</a>                  55 rpartproto.h                FLOAT *x, double *good);</span>
<span class='curline'><a href='../S/14.html#L48'>x</a>                  48 usersplit.c    void usersplit(int n,    double *y[],     FLOAT *x,     int nclass,</span>
<span class='curline'><a href='../S/14.html#L66'>x</a>                  66 usersplit.c        ftemp = x[0];</span>
<span class='curline'><a href='../S/14.html#L68'>x</a>                  68 usersplit.c            if (x[i] != ftemp) break;</span>
<span class='curline'><a href='../S/14.html#L81'>x</a>                  81 usersplit.c        rpart_callback2(n, nclass, y, wt, x, uscratch);</span>
<span class='curline'><a href='../S/14.html#L96'>x</a>                  96 usersplit.c            if ((x[i]&lt; x[i+1]) &amp;&amp; (uscratch[i] &gt; best)) {</span>
<span class='curline'><a href='../S/14.html#L104'>x</a>                 104 usersplit.c            *split = (x[where] + x[where+1]) /2;</span>
<span class='curline'><a href='../S/14.html#L126'>x</a>                 126 usersplit.c            for (j=0; j&lt;n; j++) if(x[j]==k) left_n++;</span>
<span class='curline'><a href='../S/31.html#L31'>x</a>                  31 vgdist.c       double g_manhattan(double *x, int nr, int nc, int i1, int i2)</span>
<span class='curline'><a href='../S/31.html#L39'>x</a>                  39 vgdist.c           if (R_FINITE(x[i1]) &amp;&amp; R_FINITE(x[i2])) {</span>
<span class='curline'><a href='../S/31.html#L40'>x</a>                  40 vgdist.c             dist += fabs( x[i1] - x[i2] );</span>
<span class='curline'><a href='../S/31.html#L55'>x</a>                  55 vgdist.c       double g_gower(double *x, int nr, int nc, int i1, int i2)</span>
<span class='curline'><a href='../S/31.html#L63'>x</a>                  63 vgdist.c           if (R_FINITE(x[i1]) &amp;&amp; R_FINITE(x[i2])) {</span>
<span class='curline'><a href='../S/31.html#L64'>x</a>                  64 vgdist.c             dist += fabs( x[i1] - x[i2] );</span>
<span class='curline'><a href='../S/31.html#L74'>x</a>                  74 vgdist.c       double g_euclidean(double *x, int nr, int nc, int i1, int i2)</span>
<span class='curline'><a href='../S/31.html#L82'>x</a>                  82 vgdist.c           if (R_FINITE(x[i1]) &amp;&amp; R_FINITE(x[i2])) {</span>
<span class='curline'><a href='../S/31.html#L83'>x</a>                  83 vgdist.c             dev = x[i1] - x[i2];</span>
<span class='curline'><a href='../S/31.html#L94'>x</a>                  94 vgdist.c       double g_canberra(double *x, int nr, int nc, int i1, int i2)</span>
<span class='curline'><a href='../S/31.html#L102'>x</a>                 102 vgdist.c           if (R_FINITE(x[i1]) &amp;&amp; R_FINITE(x[i2])) {</span>
<span class='curline'><a href='../S/31.html#L103'>x</a>                 103 vgdist.c             if (x[i1] != 0 || x[i2] != 0) {</span>
<span class='curline'><a href='../S/31.html#L105'>x</a>                 105 vgdist.c           denom = x[i1] + x[i2];</span>
<span class='curline'><a href='../S/31.html#L107'>x</a>                 107 vgdist.c             numer = fabs(x[i1] - x[i2]);</span>
<span class='curline'><a href='../S/31.html#L123'>x</a>                 123 vgdist.c       double g_bray(double *x, int nr, int nc, int i1, int i2)</span>
<span class='curline'><a href='../S/31.html#L132'>x</a>                 132 vgdist.c           if (R_FINITE(x[i1]) &amp;&amp; R_FINITE(x[i2])) {</span>
<span class='curline'><a href='../S/31.html#L133'>x</a>                 133 vgdist.c             dist += fabs(x[i1] - x[i2]);</span>
<span class='curline'><a href='../S/31.html#L134'>x</a>                 134 vgdist.c             total += x[i1] + x[i2];</span>
<span class='curline'><a href='../S/31.html#L145'>x</a>                 145 vgdist.c       double g_kulczynski(double *x, int nr, int nc, int i1, int i2)</span>
<span class='curline'><a href='../S/31.html#L155'>x</a>                 155 vgdist.c           if (R_FINITE(x[i1]) &amp;&amp; R_FINITE(x[i2])) {</span>
<span class='curline'><a href='../S/31.html#L156'>x</a>                 156 vgdist.c             sim += (x[i1] &lt; x[i2]) ? x[i1] : x[i2];</span>
<span class='curline'><a href='../S/31.html#L157'>x</a>                 157 vgdist.c             t1 += x[i1];</span>
<span class='curline'><a href='../S/31.html#L158'>x</a>                 158 vgdist.c             t2 += x[i2];</span>
<span class='curline'><a href='../S/31.html#L169'>x</a>                 169 vgdist.c       double g_maximum(double *x, int nr, int nc, int i1, int i2)</span>
<span class='curline'><a href='../S/31.html#L177'>x</a>                 177 vgdist.c           if (R_FINITE(x[i1]) &amp;&amp; R_FINITE(x[i2])) {</span>
<span class='curline'><a href='../S/31.html#L178'>x</a>                 178 vgdist.c               dev = fabs(x[i1] - x[i2]);</span>
<span class='curline'><a href='../S/31.html#L190'>x</a>                 190 vgdist.c       double g_binary(double *x, int nr, int nc, int i1, int i2)</span>
<span class='curline'><a href='../S/31.html#L199'>x</a>                 199 vgdist.c           if (R_FINITE(x[i1]) &amp;&amp; R_FINITE(x[i2])) {</span>
<span class='curline'><a href='../S/31.html#L200'>x</a>                 200 vgdist.c               if(x[i1] || x[i2]){</span>
<span class='curline'><a href='../S/31.html#L202'>x</a>                 202 vgdist.c               if( ! (x[i1] &amp;&amp; x[i2]) ) dist++;</span>
<span class='curline'><a href='../S/31.html#L217'>x</a>                 217 vgdist.c       void gdistance(double *x, int *nr, int *nc, double *d, int *diag, int *method)</span>
<span class='curline'><a href='../S/31.html#L250'>x</a>                 250 vgdist.c             d[ij++] = distfun(x, *nr, *nc, i, j);</span>
</pre>
</body>
</html>
